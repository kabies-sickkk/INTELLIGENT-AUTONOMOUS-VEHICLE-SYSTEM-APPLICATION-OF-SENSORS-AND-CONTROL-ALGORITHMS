#include <Arduino.h>

// ================== L298N ==================
#define IN1 26
#define IN2 27
#define ENA 25

#define IN3 12
#define IN4 13
#define ENB 14

// ================== ENCODER LEFT ==================
#define ENCL_C1 35
#define ENCL_C2 34

// ================== ENCODER RIGHT ==================
#define ENCR_C1 32
#define ENCR_C2 33

// ================== PWM (ESP32 LEDC) ==================
#define PWM_CHANNEL_A 0
#define PWM_CHANNEL_B 1
#define PWM_FREQ 1000
#define PWM_RESOLUTION 8 // 0..255

// ================== ENCODER COUNTS ==================
volatile long encoderLeftCount = 0;
volatile long encoderRightCount = 0;

// Dùng critical section để đọc biến volatile an toàn khi ISR đang update
portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;

// ================== SPEED CONFIG ==================
// Bạn chỉnh thông số này cho đúng encoder của bạn.
// Ví dụ: encoder 600 xung/vòng (tùy loại). Nếu bạn đang đếm theo 1 kênh + CHANGE
// thì PULSES_PER_REV thường là "xung thực tế mà count tăng trong 1 vòng".
const float PULSES_PER_REV = 600.0f;

// chu kỳ đo tốc độ (ms)
const uint32_t SPEED_SAMPLE_MS = 100;

// ================== INTERRUPTS ==================
void IRAM_ATTR encoderLeftISR() {
  // so sánh kênh C1/C2 để biết chiều
  if (digitalRead(ENCL_C1) == digitalRead(ENCL_C2))
    encoderLeftCount++;
  else
    encoderLeftCount--;
}

void IRAM_ATTR encoderRightISR() {
  if (digitalRead(ENCR_C1) == digitalRead(ENCR_C2))
    encoderRightCount++;
  else
    encoderRightCount--;
}

// ================== STATE FOR SPEED ==================
long lastLeftCount = 0;
long lastRightCount = 0;
uint32_t lastSpeedMillis = 0;

void setup() {
  Serial.begin(115200);

  // ---------- Motor pins ----------
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  // ---------- Encoder pins ----------
  // 34/35 input-only, không pullup nội -> dùng INPUT
  pinMode(ENCL_C1, INPUT);
  pinMode(ENCL_C2, INPUT);

  // 32/33 có pullup nội nếu cần, nhưng chỉ dùng khi encoder cho phép
  pinMode(ENCR_C1, INPUT);
  pinMode(ENCR_C2, INPUT);

  attachInterrupt(digitalPinToInterrupt(ENCL_C1), encoderLeftISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENCR_C1), encoderRightISR, CHANGE);

  // ---------- PWM ----------
  ledcSetup(PWM_CHANNEL_A, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(ENA, PWM_CHANNEL_A);

  ledcSetup(PWM_CHANNEL_B, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(ENB, PWM_CHANNEL_B);

  // ---------- Start motors forward ----------
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);

  ledcWrite(PWM_CHANNEL_A, 250);
  ledcWrite(PWM_CHANNEL_B, 250);

  lastSpeedMillis = millis();

  Serial.println("ESP32 + L298N + Dual Encoder + Speed calc");
  Serial.println("Columns: countL countR | ppsL ppsR | rpmL rpmR");
}

void loop() {
  uint32_t now = millis();

  // đo tốc độ mỗi SPEED_SAMPLE_MS
  if (now - lastSpeedMillis >= SPEED_SAMPLE_MS) {
    const float dt = (now - lastSpeedMillis) / 1000.0f; // giây
    lastSpeedMillis = now;

    long curL, curR;

    // đọc count an toàn
    portENTER_CRITICAL(&mux);
    curL = encoderLeftCount;
    curR = encoderRightCount;
    portEXIT_CRITICAL(&mux);

    long dL = curL - lastLeftCount;
    long dR = curR - lastRightCount;

    lastLeftCount = curL;
    lastRightCount = curR;

    // tốc độ dạng xung/giây
    float ppsL = dL / dt;
    float ppsR = dR / dt;

    // RPM (vòng/phút) nếu PULSES_PER_REV đúng
    float rpmL = (PULSES_PER_REV > 0) ? (ppsL / PULSES_PER_REV) * 60.0f : 0.0f;
    float rpmR = (PULSES_PER_REV > 0) ? (ppsR / PULSES_PER_REV) * 60.0f : 0.0f;

    Serial.print(curL);
    Serial.print(" ");
    Serial.print(curR);
    Serial.print(" | ");

    Serial.print(ppsL, 1);
    Serial.print(" ");
    Serial.print(ppsR, 1);
    Serial.print(" | ");

    Serial.print(rpmL, 2);
    Serial.print(" ");
    Serial.println(rpmR, 2);
  }

  // các logic khác (PID/cân bánh, MQTT...) có thể đặt ở đây
}
