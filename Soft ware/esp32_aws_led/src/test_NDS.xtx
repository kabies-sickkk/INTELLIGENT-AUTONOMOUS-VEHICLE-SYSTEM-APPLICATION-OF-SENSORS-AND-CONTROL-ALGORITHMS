/*******************************************************
 * ESP32 + AWS IoT Core Test (DNS/TCP/TLS mTLS/MQTT)
 * 1) DNS resolve
 * 2) TCP connect 8883
 * 3) TLS connect 8883 with mutual TLS (CA + device cert + key)
 * 4) MQTT connect (PubSubClient)
 *******************************************************/

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <time.h>

// ======= WiFi =======
const char* ssid     = "Phong Tro";
const char* password = "a123456a";

// ======= AWS IoT =======
const char* AWS_ENDPOINT = "a3bfjjwy5d1vo8-ats.iot.us-east-1.amazonaws.com";
static const uint16_t AWS_PORT = 8883;
#define CLIENT_ID "esp32_robot_full"

// ======= MQTT Topics (optional publish test) =======
#define TOPIC_STATUS "iot/esp32/status"

// ======= Root CA (Amazon Root CA 1) =======
static const char AWS_ROOT_CA[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
rqXRfboQnoZsG4q5WTP468SQvvG5
-----END CERTIFICATE-----
)EOF";

// ======= Device cert =======
static const char AWS_CLIENT_CERT[] PROGMEM = R"EOF(
-----BEGIN CERTIFICATE-----
MIIDWTCCAkGgAwIBAgIURsrSPKENW7v9OK7WcjYbfclb9NAwDQYJKoZIhvcNAQEL
BQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20g
SW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTI2MDEwNDE5NDA0
MloXDTQ5MTIzMTIzNTk1OVowHjEcMBoGA1UEAwwTQVdTIElvVCBDZXJ0aWZpY2F0
ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKBmgQSm8bq67ewoIc13
ra50vwLRdLzZUdig/wNysq/oop63zsPTlolBBN3/4isKpU4nWcmiw/pmBA8LPQVq
CP9e0MP1ArniEMjzdfGRdCGOWhA+Enw31tl+OpoYrxu6ZVZb83GDMx8A+6ZoHlHO
xWCOdOTv16576kLV3sOtJh363yJnvnmzNoAS3Ntm+x/EzDHbZN/vg/i7EGnTBRpn
RkVvaihxseun2cM1GgWGqrXXuM89MdUTaf0/RqnOYR+b2SghhyFcaWzJwVG4Iv5O
z5I4CDpZiV2VxPOkZxkKb9W0kYokEHTrBuQaK0wJDctPkRogQ2sTz6UJJZc+NQMj
khECAwEAAaNgMF4wHwYDVR0jBBgwFoAUfNYre7zh5bqEyfLgqKa7GRa41j0wHQYD
VR0OBBYEFA8mQI5Y1x2/wWqazGukFI5NpGD+MAwGA1UdEwEB/wQCMAAwDgYDVR0P
AQH/BAQDAgeAMA0GCSqGSIb3DQEBCwUAA4IBAQBidIV+OKTIYEqn0dHXI8WoPcbY
YaVOt8xpZCaQYqlF1SJxP3CVSymAmXG7UUuZXUfqNy68EmhaaYh3Er4Pp6arDOAa
uBagLLokSsdnP7OcQrmVRvjTkPXjTaB/U34rlvaAMTRfHvKsMk6Uu9zeq2A4Jzdt
x5Q9mZ1t8oMRif23o3wMuup1sINCsijn6tSPjRftUgPQtDD5dtDb40p/QN1GCJPG
O9tte1W/1QBrjjJglYXIuVOjyxKHmXVmRvlDIcujWw4O/bIRLHT1NjftJdvOlNkg
ypWqLUTLLqz6c7z0TOsaoWA4CtHZSM1/GmCJS9Jqv8psXWqB6NgoHyypsCEf
-----END CERTIFICATE-----

)EOF";

// ======= Private key =======
static const char AWS_PRIVATE_KEY[] PROGMEM = R"EOF(
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAoGaBBKbxurrt7CghzXetrnS/AtF0vNlR2KD/A3Kyr+iinrfO
w9OWiUEE3f/iKwqlTidZyaLD+mYEDws9BWoI/17Qw/UCueIQyPN18ZF0IY5aED4S
fDfW2X46mhivG7plVlvzcYMzHwD7pmgeUc7FYI505O/XrnvqQtXew60mHfrfIme+
ebM2gBLc22b7H8TMMdtk3++D+LsQadMFGmdGRW9qKHGx66fZwzUaBYaqtde4zz0x
1RNp/T9Gqc5hH5vZKCGHIVxpbMnBUbgi/k7PkjgIOlmJXZXE86RnGQpv1bSRiiQQ
dOsG5BorTAkNy0+RGiBDaxPPpQkllz41AyOSEQIDAQABAoIBAAbYeRcmvNhYVAEp
MVAglHQGnYRURiQtLjYNoPSXt5KUXiRh+dwXsqwG71s+KXvmx2lPeqCFZtHP+spd
k2wgu2OSu1wxn70pLcg1w8nciFVKSwO4cneEtpGvtnaPKSII0XxfDkPA8rSXCSZv
+SNKrNfTHKAMsGrM9RGHKSu2vxK2afROT5lLwfsOOV4U02niHozL/DCJk1nUZknM
3CnJxirqsEeJTDi2wW1dCTJMRfYgbkuwzmGAaFfakst7HrhyOSxIyCXGbNqaeq3o
7zq0xrcLkkjlsreYJ4PpL1IOnghe3fxlX27Zzx3KiawWxrUFqwgBSXtjZ4nMNp/i
wdUQx1UCgYEAz3TVG/Dimz5NTsYNtYRF+9Jdkm6jFHIg+SuU/RgWcxLhd6VFqC/A
AC7S0EjRw5B0XYaXjAYfDLZc82FWctmAsHCGj5Q2LN0JulHsFyFL/8qWd88XatVg
+Y8ytDaJ0BABoPOhmb+tiauUT7MmK2ru+ajCXeUv9GR12xQS0RQBgN8CgYEAxe7m
Bj4wIozldYa7hrWfinRPgsQ+Ql22XJofGT+Ngt2KFdIyvdt8BMTxM46gMbQiPhNe
hmL49HR408gQfLqf6FPYbvFRkAf8UUiBKjEILFRfc6L/46dWSIDYR2kNYkR4+IbT
Y471vDpLJZW7usOOzsE9iwhq3W4tqGjdzTS6mw8CgYEAjkKSxOdJraVqhANCcV/0
UbwvGHQv9pxQyi09rNUwx9aBsHcwLiYYZse1Hslgtte/REdAcu/bqO8BDJCKJJXM
LrHrRFghUmB9BDybRj06DX1R83SanVMXferZnUTs+jWPuFx5S6JqkUaMnJ7AJPPe
TmuQZaz9VnzxaLr6ME+kvEcCgYBBTV5KtP3AiGez7K219foa/eC1rfU0hCKETrzv
4Y3YnSrPpDfld6JlGGzTq7yiaWHaxR0sjT7BuCOdC6aU4CWdyvvfLnLQaDIQxzEG
MIMXzQZo6mAuRakr5oZ0mO43e4vFwwW/FQ1x+nGMhugW6CoXgJ3DXxWS1KTvqRl0
eG8QdQKBgC3paUXXgd0XI6w+Y7ooYnj7snwAFg5OkBTRSlcVE/2AqtKlL0RZJYyR
GDh2sp0MVLD9eoURfF0DYOy24wE0e7XDFYkdkZHzGAabDD/U1BEPqXQfAgeYDsj6
aICqwMGporjqhiivCOXm+X1N2trQrJn++xxZA+MVC02LN5OsCMQi
-----END RSA PRIVATE KEY-----

)EOF";

// ======= Clients =======
WiFiClientSecure tls;
PubSubClient mqtt(tls);

static void printLocalTime() {
  time_t now = time(nullptr);
  struct tm t;
  if (localtime_r(&now, &t)) {
    char buf[64];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &t);
    Serial.print("[TIME] "); Serial.print(buf);
    Serial.print(" (epoch="); Serial.print((long)now); Serial.println(")");
  } else {
    Serial.println("[TIME] not available");
  }
}

static bool waitForTimeSync(uint32_t timeoutMs = 15000) {
  Serial.println("[TIME] Sending NTP request...");
  configTime(7 * 3600, 0, "pool.ntp.org", "time.nist.gov");

  uint32_t start = millis();
  while (millis() - start < timeoutMs) {
    time_t now = time(nullptr);
    if (now > 1609459200) { // 2021-01-01
      Serial.println("[TIME] Time synced.");
      printLocalTime();
      return true;
    }
    delay(250);
  }
  Serial.println("[TIME] Time sync TIMEOUT!");
  printLocalTime();
  return false;
}

static void testDNS() {
  IPAddress ip;
  Serial.print("[TEST] DNS resolve "); Serial.print(AWS_ENDPOINT); Serial.print(" ... ");
  if (WiFi.hostByName(AWS_ENDPOINT, ip)) {
    Serial.print("OK -> "); Serial.println(ip);
  } else {
    Serial.println("FAIL (DNS)");
  }
}

static void testTCP() {
  WiFiClient tcp;
  Serial.print("[TEST] TCP connect "); Serial.print(AWS_ENDPOINT);
  Serial.print(":"); Serial.print(AWS_PORT); Serial.print(" ... ");
  if (tcp.connect(AWS_ENDPOINT, AWS_PORT)) {
    Serial.println("OK");
    tcp.stop();
  } else {
    Serial.println("FAIL");
  }
}

static void printTLSError(WiFiClientSecure& c) {
  char sslerr[256];
  int err = c.lastError(sslerr, sizeof(sslerr));
  Serial.print("[TLS] lastError code="); Serial.println(err);
  Serial.print("[TLS] lastError msg="); Serial.println(sslerr);
}

static void setupTLSCreds() {
  tls.setCACert(AWS_ROOT_CA);
  tls.setCertificate(AWS_CLIENT_CERT);
  tls.setPrivateKey(AWS_PRIVATE_KEY);
  tls.setHandshakeTimeout(15); // seconds
}

static void testTLS_mTLS() {
  setupTLSCreds();
  Serial.print("[TEST] TLS(mTLS) connect "); Serial.print(AWS_ENDPOINT);
  Serial.print(":"); Serial.print(AWS_PORT); Serial.print(" ... ");
  if (tls.connect(AWS_ENDPOINT, AWS_PORT)) {
    Serial.println("OK (mTLS established)");
    tls.stop();
  } else {
    Serial.println("FAIL (mTLS)");
    printTLSError(tls);
  }
}

static void testMQTT() {
  setupTLSCreds();
  mqtt.setServer(AWS_ENDPOINT, AWS_PORT);

  Serial.print("[TEST] MQTT connect clientId="); Serial.print(CLIENT_ID); Serial.print(" ... ");
  if (mqtt.connect(CLIENT_ID)) {
    Serial.println("OK (MQTT CONNECTED)");
    mqtt.publish(TOPIC_STATUS, "HELLO_FROM_ESP32_TEST", true);
    mqtt.disconnect();
  } else {
    Serial.print("FAIL, state="); Serial.println(mqtt.state());
    printTLSError(tls);
  }
}

void setup() {
  Serial.begin(115200);
  delay(500);

  WiFi.mode(WIFI_STA);
  WiFi.setAutoReconnect(true);
  WiFi.setSleep(false);

  Serial.println();
  Serial.println("===== ESP32 AWS IoT mTLS/MQTT Test =====");
  Serial.print("[WIFI] Connecting to "); Serial.println(ssid);

  WiFi.begin(ssid, password);

  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
    delay(300);
    Serial.print(".");
  }
  Serial.println();

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("[WIFI] FAIL");
    return;
  }

  Serial.println("[WIFI] OK");
  Serial.print("[WIFI] IP: "); Serial.println(WiFi.localIP());
  Serial.print("[WIFI] RSSI: "); Serial.print(WiFi.RSSI()); Serial.println(" dBm");

  waitForTimeSync();

  testDNS();
  testTCP();
  testTLS_mTLS();
  testMQTT();

  Serial.println("===== DONE. Re-run every 20s =====");
}

void loop() {
  static uint32_t last = 0;
  if (millis() - last > 20000) {
    last = millis();
    Serial.println();
    printLocalTime();
    testDNS();
    testTCP();
    testTLS_mTLS();
    testMQTT();
  }
}
